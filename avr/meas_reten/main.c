#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/power.h>
#include <avr/eeprom.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <util/atomic.h>
#include "hw.h"
#include "scheduler.h"
#include "comm.h"

static volatile uint32_t flow_pulses;
static volatile uint32_t distance_avg;
static volatile uint32_t distance_err;
static uint16_t last_distance;

#define DIST_FILTER(x) (x >> 6)
#define abs(__x) ((__x > 0) ? (__x) : -(__x))

static const uint16_t tbl_litres[] PROGMEM = {
    2554, 2552, 2551, 2549, 2548, 2546, 2545, 2543, 2542, 2540, 2539, 2537, 2536, 2534, 2533, 2531, 2530,
    2528, 2527, 2525, 2524, 2522, 2521, 2519, 2518, 2516, 2514, 2513, 2511, 2510, 2508, 2507, 2505, 2504,
    2502, 2500, 2499, 2497, 2496, 2494, 2492, 2491, 2489, 2488, 2486, 2484, 2483, 2481, 2479, 2478, 2476,
    2475, 2473, 2471, 2470, 2468, 2466, 2465, 2463, 2461, 2460, 2458, 2456, 2455, 2453, 2451, 2449, 2448,
    2446, 2444, 2443, 2441, 2439, 2438, 2436, 2434, 2432, 2431, 2429, 2427, 2425, 2424, 2422, 2420, 2418,
    2417, 2415, 2413, 2411, 2410, 2408, 2406, 2404, 2403, 2401, 2399, 2397, 2395, 2394, 2392, 2390, 2388,
    2386, 2385, 2383, 2381, 2379, 2377, 2375, 2374, 2372, 2370, 2368, 2366, 2364, 2363, 2361, 2359, 2357,
    2355, 2353, 2351, 2350, 2348, 2346, 2344, 2342, 2340, 2338, 2336, 2334, 2333, 2331, 2329, 2327, 2325,
    2323, 2321, 2319, 2317, 2315, 2313, 2311, 2310, 2308, 2306, 2304, 2302, 2300, 2298, 2296, 2294, 2292,
    2290, 2288, 2286, 2284, 2282, 2280, 2278, 2276, 2274, 2272, 2270, 2268, 2266, 2264, 2262, 2260, 2258,
    2256, 2254, 2252, 2250, 2248, 2246, 2244, 2242, 2240, 2238, 2236, 2234, 2232, 2230, 2228, 2226, 2224,
    2222, 2220, 2218, 2215, 2213, 2211, 2209, 2207, 2205, 2203, 2201, 2199, 2197, 2195, 2193, 2191, 2188,
    2186, 2184, 2182, 2180, 2178, 2176, 2174, 2172, 2169, 2167, 2165, 2163, 2161, 2159, 2157, 2155, 2152,
    2150, 2148, 2146, 2144, 2142, 2140, 2137, 2135, 2133, 2131, 2129, 2127, 2124, 2122, 2120, 2118, 2116,
    2114, 2111, 2109, 2107, 2105, 2103, 2100, 2098, 2096, 2094, 2092, 2089, 2087, 2085, 2083, 2081, 2078,
    2076, 2074, 2072, 2069, 2067, 2065, 2063, 2061, 2058, 2056, 2054, 2052, 2049, 2047, 2045, 2043, 2040,
    2038, 2036, 2034, 2031, 2029, 2027, 2025, 2022, 2020, 2018, 2015, 2013, 2011, 2009, 2006, 2004, 2002,
    2000, 1997, 1995, 1993, 1990, 1988, 1986, 1983, 1981, 1979, 1977, 1974, 1972, 1970, 1967, 1965, 1963,
    1960, 1958, 1956, 1953, 1951, 1949, 1946, 1944, 1942, 1939, 1937, 1935, 1932, 1930, 1928, 1925, 1923,
    1921, 1918, 1916, 1914, 1911, 1909, 1907, 1904, 1902, 1899, 1897, 1895, 1892, 1890, 1888, 1885, 1883,
    1880, 1878, 1876, 1873, 1871, 1869, 1866, 1864, 1861, 1859, 1857, 1854, 1852, 1849, 1847, 1845, 1842,
    1840, 1837, 1835, 1833, 1830, 1828, 1825, 1823, 1821, 1818, 1816, 1813, 1811, 1808, 1806, 1804, 1801,
    1799, 1796, 1794, 1791, 1789, 1787, 1784, 1782, 1779, 1777, 1774, 1772, 1769, 1767, 1765, 1762, 1760,
    1757, 1755, 1752, 1750, 1747, 1745, 1742, 1740, 1738, 1735, 1733, 1730, 1728, 1725, 1723, 1720, 1718,
    1715, 1713, 1710, 1708, 1705, 1703, 1700, 1698, 1696, 1693, 1691, 1688, 1686, 1683, 1681, 1678, 1676,
    1673, 1671, 1668, 1666, 1663, 1661, 1658, 1656, 1653, 1651, 1648, 1646, 1643, 1641, 1638, 1636, 1633,
    1631, 1628, 1626, 1623, 1621, 1618, 1616, 1613, 1611, 1608, 1605, 1603, 1600, 1598, 1595, 1593, 1590,
    1588, 1585, 1583, 1580, 1578, 1575, 1573, 1570, 1568, 1565, 1563, 1560, 1557, 1555, 1552, 1550, 1547,
    1545, 1542, 1540, 1537, 1535, 1532, 1530, 1527, 1524, 1522, 1519, 1517, 1514, 1512, 1509, 1507, 1504,
    1502, 1499, 1496, 1494, 1491, 1489, 1486, 1484, 1481, 1479, 1476, 1473, 1471, 1468, 1466, 1463, 1461,
    1458, 1456, 1453, 1450, 1448, 1445, 1443, 1440, 1438, 1435, 1433, 1430, 1427, 1425, 1422, 1420, 1417,
    1415, 1412, 1409, 1407, 1404, 1402, 1399, 1397, 1394, 1391, 1389, 1386, 1384, 1381, 1379, 1376, 1373,
    1371, 1368, 1366, 1363, 1361, 1358, 1355, 1353, 1350, 1348, 1345, 1343, 1340, 1337, 1335, 1332, 1330,
    1327, 1325, 1322, 1319, 1317, 1314, 1312, 1309, 1306, 1304, 1301, 1299, 1296, 1294, 1291, 1288, 1286,
    1283, 1281, 1278, 1276, 1273, 1270, 1268, 1265, 1263, 1260, 1257, 1255, 1252, 1250, 1247, 1245, 1242,
    1239, 1237, 1234, 1232, 1229, 1227, 1224, 1221, 1219, 1216, 1214, 1211, 1208, 1206, 1203, 1201, 1198,
    1196, 1193, 1190, 1188, 1185, 1183, 1180, 1178, 1175, 1172, 1170, 1167, 1165, 1162, 1160, 1157, 1154,
    1152, 1149, 1147, 1144, 1142, 1139, 1136, 1134, 1131, 1129, 1126, 1124, 1121, 1118, 1116, 1113, 1111,
    1108, 1106, 1103, 1100, 1098, 1095, 1093, 1090, 1088, 1085, 1082, 1080, 1077, 1075, 1072, 1070, 1067,
    1064, 1062, 1059, 1057, 1054, 1052, 1049, 1047, 1044, 1041, 1039, 1036, 1034, 1031, 1029, 1026, 1024,
    1021, 1018, 1016, 1013, 1011, 1008, 1006, 1003, 1001, 998, 996, 993, 990, 988, 985, 983, 980, 978,
    975, 973, 970, 968, 965, 962, 960, 957, 955, 952, 950, 947, 945, 942, 940, 937, 935, 932, 930, 927,
    924, 922, 919, 917, 914, 912, 909, 907, 904, 902, 899, 897, 894, 892, 889, 887, 884, 882, 879, 877,
    874, 872, 869, 867, 864, 862, 859, 857, 854, 852, 849, 847, 844, 842, 839, 837, 834, 832, 829, 827,
    824, 822, 819, 817, 814, 812, 809, 807, 804, 802, 799, 797, 794, 792, 790, 787, 785, 782, 780, 777,
    775, 772, 770, 767, 765, 762, 760, 757, 755, 753, 750, 748, 745, 743, 740, 738, 735, 733, 731, 728,
    726, 723, 721, 718, 716, 713, 711, 709, 706, 704, 701, 699, 697, 694, 692, 689, 687, 684, 682, 680,
    677, 675, 672, 670, 668, 665, 663, 660, 658, 656, 653, 651, 648, 646, 644, 641, 639, 636, 634, 632,
    629, 627, 625, 622, 620, 617, 615, 613, 610, 608, 606, 603, 601, 598, 596, 594, 591, 589, 587, 584,
    582, 580, 577, 575, 573, 570, 568, 566, 563, 561, 559, 556, 554, 552, 549, 547, 545, 542, 540, 538,
    535, 533, 531, 529, 526, 524, 522, 519, 517, 515, 512, 510, 508, 506, 503, 501, 499, 496, 494, 492,
    490, 487, 485, 483, 481, 478, 476, 474, 472, 469, 467, 465, 463, 460, 458, 456, 454, 451, 449, 447,
    445, 442, 440, 438, 436, 434, 431, 429, 427, 425, 422, 420, 418, 416, 414, 411, 409, 407, 405, 403,
    400, 398, 396, 394, 392, 390, 387, 385, 383, 381, 379, 377, 374, 372, 370, 368, 366, 364, 362, 359,
    357, 355, 353, 351, 349, 347, 344, 342, 340, 338, 336, 334, 332, 330, 328, 325, 323, 321, 319, 317,
    315, 313, 311, 309, 307, 305, 302, 300, 298, 296, 294, 292, 290, 288, 286, 284, 282, 280, 278, 276,
    274, 272, 270, 268, 265, 263, 261, 259, 257, 255, 253, 251, 249, 247, 245, 243, 241, 239, 237, 235,
    233, 231, 229, 227, 225, 223, 222, 220, 218, 216, 214, 212, 210, 208, 206, 204, 202, 200, 198, 196,
    194, 192, 190, 188, 187, 185, 183, 181, 179, 177, 175, 173, 171, 169, 168, 166, 164, 162, 160, 158,
    156, 154, 153, 151, 149, 147, 145, 143, 141, 140, 138, 136, 134, 132, 130, 129, 127, 125, 123, 121,
    120, 118, 116, 114, 112, 111, 109, 107, 105, 103, 102, 100, 98, 96, 95, 93, 91, 89, 88, 86, 84, 82,
    81, 79, 77, 75, 74, 72, 70, 68, 67, 65, 63, 62, 60, 58, 57, 55, 53, 52, 50, 48, 47, 45, 43, 42, 40,
    38, 37, 35, 33, 32, 30, 28, 27, 25, 23, 22, 20, 19, 17, 15, 14, 12, 11, 9, 7, 6, 4, 3, 1, 0
};


ISR(TIMER1_COMPA_vect)
{
    TickCounter++;
}


ISR(PCINT0_vect)
{
    // flow sensor
    if (flow_in()) flow_pulses++;
}


ISR(TIMER2_COMPA_vect)
{
    uint8_t sample = dist_uart_in();
    static uint8_t bits;
    static uint32_t recv1, recv2;

    if (bits <= 8) {
        recv1 >>= 1;
        if (sample) recv1 |= 0x00000100;
        bits++;
    }
    else if (bits <= 38) {
        recv2 >>= 1;
        if (sample) recv2 |= 0x20000000;
        bits++;
    }

    if (bits == 39) {
        TCCR2B = 0; // stop
        if (recv1 == 0x1FF) {
            uint8_t data[3];
            data[0] = recv2 >> 1;
            data[1] = recv2 >> 11;
            data[2] = recv2 >> 21;

            if ((((uint16_t)0xFF + data[0] + data[1]) & 0xFF) == data[2]) {
                uint16_t distance_new = (data[0] << 8) + data[1];
                int16_t error = distance_new - DIST_FILTER(distance_avg);

                distance_avg -= DIST_FILTER(distance_avg);
                distance_avg += distance_new;
                distance_err -= DIST_FILTER(distance_err);
                distance_err += abs(error);

                ResetDelay(&last_distance);
            }
        } else {
            _delay_ms(5); // not in sync - blocking wait
        }
        recv1 = 0;
        recv2 = 0;
        bits = 0;
        PCIFR = _BV(PCIF1);
        PCICR |= _BV(PCIE1);
    }
}


ISR(PCINT1_vect)
{
    // UART z merice vzdalenosti, mirne prasacke, ale funkcni reseni
    PCICR &= ~_BV(PCIE1);
    TCNT2 = 0;
    _delay_us(8);
    TCCR2B = _BV(CS20);
}


void comm_execute(uint8_t cmd, uint16_t value)
{
    uint32_t flow_pulses_cpy;
    uint16_t distance_avg_cpy, distance_err_cpy;
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
        flow_pulses_cpy = flow_pulses;
        if (HasDelayElapsed(1000, &last_distance, false)) {
            distance_avg_cpy = 65535;
            distance_err_cpy = 65535;
        } else {
            distance_avg_cpy = DIST_FILTER(distance_avg);
            distance_err_cpy = DIST_FILTER(distance_err);
        }
    }

    switch (cmd) {
        case GET_PULSES_LO:
            comm_send(ADDR_RESP_ID, GET_PULSES_LO, (flow_pulses_cpy));
            break;
        case GET_PULSES_HI:
            comm_send(ADDR_RESP_ID, GET_PULSES_HI, (flow_pulses_cpy >> 16));
            break;
        case GET_LITRES:
            comm_send(ADDR_RESP_ID, GET_LITRES, flow_pulses_cpy / eeprom_read_word(ADDR_PULSES_L));
            break;
        case RESET_FLOW:
            ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
                flow_pulses = 0;
            }
            break;

        case GET_DIST:
            if (distance_avg_cpy > 2047) distance_avg_cpy = 2047;
            if (distance_err_cpy > 31) distance_err_cpy = 31;
            comm_send(ADDR_RESP_ID, GET_DIST, distance_avg_cpy | (distance_err_cpy << 11));
            break;
        case GET_OCCUP:
            if (distance_avg_cpy < 265) distance_avg_cpy = 265;
            if (distance_avg_cpy > 1414) distance_avg_cpy = 1414;
            uint16_t litres = pgm_read_word(&tbl_litres[distance_avg_cpy - 265]);
            comm_send(ADDR_RESP_ID, GET_OCCUP, litres);
            break;

        case SET_PULSES_L:
            eeprom_write_word(ADDR_PULSES_L, value);
            break;
        case GET_PULSES_L:
            comm_send(ADDR_RESP_ID, GET_PULSES_L, eeprom_read_word(ADDR_PULSES_L));
            break;
    }
}


int main(void)
{
    clock_prescale_set(clock_div_8);

    // timer pro soft prijem UARTu
    OCR2A = (uint8_t)(F_CPU/9600)-1;
    TCCR2A = _BV(WGM21);
    TCCR2B = 0; /* _BV(CS20) */
    TIMSK2 |= _BV(OCIE2A);

    PCMSK0 |= _BV(PCINT1); // flow sensor
    PCMSK1 |= _BV(PCINT10); // UART z merice vzdalenosti
    PCICR |= _BV(PCIE0) | _BV(PCIE1);

    comm_init();

    OCR1A = (uint16_t)(F_CPU/8*0.001)-1;
    TCCR1B |= _BV(CS11) | _BV(WGM12);
    TIMSK1 |= _BV(OCIE1A);
    sei();

    // nastaveni vychozi hodnoty pulsu na litr
    if (eeprom_read_word(ADDR_PULSES_L) == UINT16_MAX) {
        eeprom_write_word(ADDR_PULSES_L, 405); // 4049 pulsu = 10 litru
    }

    while (1) {
        // obsluha komunikace
        comm_task();

        // vse ostatni v ISR

    }
}
